import numpy as np
import math
import copy

def emission(x,y,xset,yset):
	ycount = {}
	for i in yset:
		ycount[i] = sum([1. for j in y if i==j])

	e = {}
	for i in xset:
		for j in yset:
			e[j,i] = 0.

	for i,j in zip(x,y):
		e[j,i] = e[j,i] + 1./(ycount[j]+1)

	for j in yset:
		e[j,'NA'] = 1./(ycount[j]+1)	

	return e,ycount

def transition(xset,yset):

	a = {}
	for i in yset:
		for j in yset:
			a[i,j] = 0.
	xtrain = ['']
	ytrain = ['START']
	f = open('train', 'r')
	for line in f:
		if line.strip():
			line = line.split(' ')
			xtrain.append(line[0])
			ytrain.append(line[1].strip())
		else:
			xtrain.append('')
			ytrain.append('STOP')
			xtrain.append('')
			ytrain.append('START')			
	f.close()
	del xtrain[-1]
	del ytrain[-1]

	ycount = {}
	for i in yset:
		ycount[i] = sum([1. for j in ytrain if i==j])
	for i in range(len(ytrain)-1):
		a[ytrain[i], ytrain[i+1]] = a[ytrain[i], ytrain[i+1]] + 1.
	
	ycountzero = {}
	for i in yset:
		ycountzero[i] = 0.
		for j in yset:
			if a[i,j] == 0.:
				ycountzero[i] = ycountzero[i]+1
	for i in yset:
		for j in yset:
			if a[i,j]==0.:
				a[i,j] = 1./(ycount[i]+ycountzero[i])
			else:
				a[i,j] = a[i,j]/(ycount[i]+ycountzero[i])
				
	return a, ycount

def Viterbi(e,a,x,yset):
	pi = [[(0.,[]) for j in range(len(yset)-2)] for i in range(len(x)+2)]
	pi[0][0] = (math.log(1.), [yset[0]])

	for j in range(1,len(yset)-1):
		path = copy.deepcopy(pi[0][0][1])
		path.append(yset[j])
		score = 0.0
		if x[0] in xset:
			if a['START', yset[j]]!=0. and e[yset[j],x[0]]!=0.:
				score = math.log(a['START', yset[j]])+math.log(e[yset[j],x[0]])
		else:
			if a['START', yset[j]]!=0. and e[yset[j],'NA']!=0.:
				score = math.log(a['START', yset[j]])+math.log(e[yset[j],'NA'])

		pi[1][j-1] = (score,path)

	for i in range(1,len(x)):
		for j in range(1,len(yset)-1):
			tmp = []
			for k in range(1,len(yset)-1):
					score = 0.0
					if x[i] in xset:
						if a[yset[k],yset[j]]!=0. and e[yset[j],x[i]]!=0. and pi[i][k-1][0]!=0.:
							score = pi[i][k-1][0]+ math.log(a[yset[k],yset[j]])+ math.log(e[yset[j],x[i]])
					else:
						if a[yset[k],yset[j]]!=0. and e[yset[j],'NA']!=0. and pi[i][k-1][0]!=0.:
							score = pi[i][k-1][0]+ math.log(a[yset[k],yset[j]])+ math.log(e[yset[j],'NA'])
					path = copy.deepcopy(pi[i][k-1][1])
					path.append(yset[j])
					if score!=0.0:
						tmp.append((score,path))
			temp = sorted(tmp, key=lambda tmp: tmp[0], reverse=True)
			if temp:
				pi[i+1][j-1] = temp[0]
			else:
				pi[i+1][j-1] = (score,path)

	tmp = []
	for k in range(1,len(yset)-1):
			score = 0.0
			if a[yset[k],'STOP']!=0. and pi[-2][k-1][0]!=0.:
				score = pi[-2][k-1][0] + math.log(a[yset[k],'STOP'])
			path = copy.deepcopy(pi[-2][k-1][1])
			path.append('STOP')
			if score!= 0.:
				tmp.append((score,path))
	temp = sorted(tmp, key=lambda tmp: tmp[0], reverse=True)
	if temp:
		pi[-1][0] = temp[0]
	else:
		pi[-1][0] = (score,path)
	
	return pi[-1][0]

def tagging(e,a,xtest,yset):
	ypred = []

	flag = True
	for i in range(len(xtest)):
		if xtest[i]=='':
			if flag:
				sentence = []
				flag = False
			else:
				(score, sentence_tag) = Viterbi(e,a,sentence,yset)
				for j in range(1,len(sentence_tag)-1):
					ypred.append(sentence_tag[j])
				flag = True
		else:
			sentence.append(xtest[i])

	return ypred

def readin():
	xtest = ['']
	ytest = []
	f = open('dev.in','r')
	for line in f:
		if line.strip():
			xtest.append(line.strip())
		else:
			xtest.append('')
			xtest.append('')
	f.close()
	del xtest[-1]

	f = open('dev.out','r')
	for line in f:
		if line.strip():
			line = line.split(' ')
			ytest.append(line[1].strip())
		# else:
		# 	ytest.append('STOP')
		# 	ytest.append('START')
	f.close()
	# del ytest[-1]
	return xtest,ytest

def init():
	xtrain = []
	ytrain = []
	f = open('train', 'r')
	for line in f:
		if line.strip():
			line = line.split(' ')
			xtrain.append(line[0])
			ytrain.append(line[1].strip())
	f.close()
	return xtrain, ytrain

def writefile(ypred):
	f1 = open('dev.p3.out','w')
	f2 = open('dev.in','r')
	count = 0
	for line in f2:
		if line.strip():
			f1.write(line.strip()+' '+ypred[count]+'\n')
			count += 1
		else:
			f1.write('\n')
	f1.close()
	f2.close()
	return None

if __name__ == "__main__":

	xtrain, ytrain = init()
	xset = sorted(list(set(xtrain)))
	yset = sorted(list(set(ytrain)))

	e, ycount = emission(xtrain,ytrain,xset,yset)

	yset.insert(0, 'START')
	yset.append('STOP')

	a, ycount = transition(xset,yset)

	xtest, ytest = readin()

	ypred = tagging(e, a, xtest, yset)

	writefile(ypred);

	accuracy = sum([1. for i,j in zip(ypred,ytest) if i==j])/len(ypred)
	print accuracy

